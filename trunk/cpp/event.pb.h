// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: event.proto

#ifndef PROTOBUF_event_2eproto__INCLUDED
#define PROTOBUF_event_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace guiprotocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_event_2eproto();
void protobuf_AssignDesc_event_2eproto();
void protobuf_ShutdownFile_event_2eproto();

class GameEvent;
class GameEvent_FireEmitter;

enum GameEvent_EventType {
  GameEvent_EventType_GAME_INFO_REFRESH = 0,
  GameEvent_EventType_FIRE_EMITTER_CHANGED = 1,
  GameEvent_EventType_GAME_STATE_CHANGED = 2,
  GameEvent_EventType_PLAYER_HEALTH_CHANGED = 3,
  GameEvent_EventType_ROUND_PLAY_TIMER_CHANGED = 4,
  GameEvent_EventType_ROUND_BEGIN_TIMER_CHANGED = 5,
  GameEvent_EventType_ROUND_ENDED = 6,
  GameEvent_EventType_MATCH_ENDED = 7,
  GameEvent_EventType_PLAYER_ATTACK_ACTION = 8,
  GameEvent_EventType_PLAYER_BLOCK_ACTION = 9,
  GameEvent_EventType_RINGMASTER_ACTION = 10,
  GameEvent_EventType_SYSTEM_INFO_REFRESH = 11,
  GameEvent_EventType_UNRECOGNIZED_GESTURE = 12
};
bool GameEvent_EventType_IsValid(int value);
const GameEvent_EventType GameEvent_EventType_EventType_MIN = GameEvent_EventType_GAME_INFO_REFRESH;
const GameEvent_EventType GameEvent_EventType_EventType_MAX = GameEvent_EventType_UNRECOGNIZED_GESTURE;
const int GameEvent_EventType_EventType_ARRAYSIZE = GameEvent_EventType_EventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameEvent_EventType_descriptor();
inline const ::std::string& GameEvent_EventType_Name(GameEvent_EventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameEvent_EventType_descriptor(), value);
}
inline bool GameEvent_EventType_Parse(
    const ::std::string& name, GameEvent_EventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameEvent_EventType>(
    GameEvent_EventType_descriptor(), name, value);
}
enum GameEvent_RoundResult {
  GameEvent_RoundResult_ROUND_TIE = 0,
  GameEvent_RoundResult_PLAYER_1_ROUND_WIN = 1,
  GameEvent_RoundResult_PLAYER_2_ROUND_WIN = 2
};
bool GameEvent_RoundResult_IsValid(int value);
const GameEvent_RoundResult GameEvent_RoundResult_RoundResult_MIN = GameEvent_RoundResult_ROUND_TIE;
const GameEvent_RoundResult GameEvent_RoundResult_RoundResult_MAX = GameEvent_RoundResult_PLAYER_2_ROUND_WIN;
const int GameEvent_RoundResult_RoundResult_ARRAYSIZE = GameEvent_RoundResult_RoundResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameEvent_RoundResult_descriptor();
inline const ::std::string& GameEvent_RoundResult_Name(GameEvent_RoundResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameEvent_RoundResult_descriptor(), value);
}
inline bool GameEvent_RoundResult_Parse(
    const ::std::string& name, GameEvent_RoundResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameEvent_RoundResult>(
    GameEvent_RoundResult_descriptor(), name, value);
}
enum GameEvent_MatchResult {
  GameEvent_MatchResult_PLAYER_1_MATCH_WIN = 0,
  GameEvent_MatchResult_PLAYER_2_MATCH_WIN = 1
};
bool GameEvent_MatchResult_IsValid(int value);
const GameEvent_MatchResult GameEvent_MatchResult_MatchResult_MIN = GameEvent_MatchResult_PLAYER_1_MATCH_WIN;
const GameEvent_MatchResult GameEvent_MatchResult_MatchResult_MAX = GameEvent_MatchResult_PLAYER_2_MATCH_WIN;
const int GameEvent_MatchResult_MatchResult_ARRAYSIZE = GameEvent_MatchResult_MatchResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameEvent_MatchResult_descriptor();
inline const ::std::string& GameEvent_MatchResult_Name(GameEvent_MatchResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameEvent_MatchResult_descriptor(), value);
}
inline bool GameEvent_MatchResult_Parse(
    const ::std::string& name, GameEvent_MatchResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameEvent_MatchResult>(
    GameEvent_MatchResult_descriptor(), name, value);
}
enum GameEvent_FireEmitterType {
  GameEvent_FireEmitterType_LEFT_RAIL = 0,
  GameEvent_FireEmitterType_RIGHT_RAIL = 1,
  GameEvent_FireEmitterType_OUTER_RING = 2
};
bool GameEvent_FireEmitterType_IsValid(int value);
const GameEvent_FireEmitterType GameEvent_FireEmitterType_FireEmitterType_MIN = GameEvent_FireEmitterType_LEFT_RAIL;
const GameEvent_FireEmitterType GameEvent_FireEmitterType_FireEmitterType_MAX = GameEvent_FireEmitterType_OUTER_RING;
const int GameEvent_FireEmitterType_FireEmitterType_ARRAYSIZE = GameEvent_FireEmitterType_FireEmitterType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameEvent_FireEmitterType_descriptor();
inline const ::std::string& GameEvent_FireEmitterType_Name(GameEvent_FireEmitterType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameEvent_FireEmitterType_descriptor(), value);
}
inline bool GameEvent_FireEmitterType_Parse(
    const ::std::string& name, GameEvent_FireEmitterType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameEvent_FireEmitterType>(
    GameEvent_FireEmitterType_descriptor(), name, value);
}
enum GameEvent_FlameEmitterType {
  GameEvent_FlameEmitterType_ATTACK_FLAME = 0,
  GameEvent_FlameEmitterType_BLOCK_FLAME = 1,
  GameEvent_FlameEmitterType_NON_GAME_FLAME = 2
};
bool GameEvent_FlameEmitterType_IsValid(int value);
const GameEvent_FlameEmitterType GameEvent_FlameEmitterType_FlameEmitterType_MIN = GameEvent_FlameEmitterType_ATTACK_FLAME;
const GameEvent_FlameEmitterType GameEvent_FlameEmitterType_FlameEmitterType_MAX = GameEvent_FlameEmitterType_NON_GAME_FLAME;
const int GameEvent_FlameEmitterType_FlameEmitterType_ARRAYSIZE = GameEvent_FlameEmitterType_FlameEmitterType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameEvent_FlameEmitterType_descriptor();
inline const ::std::string& GameEvent_FlameEmitterType_Name(GameEvent_FlameEmitterType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameEvent_FlameEmitterType_descriptor(), value);
}
inline bool GameEvent_FlameEmitterType_Parse(
    const ::std::string& name, GameEvent_FlameEmitterType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameEvent_FlameEmitterType>(
    GameEvent_FlameEmitterType_descriptor(), name, value);
}
enum GameEvent_AttackType {
  GameEvent_AttackType_CUSTOM_UNDEFINED = 0,
  GameEvent_AttackType_LEFT_JAB = 1,
  GameEvent_AttackType_RIGHT_JAB = 2,
  GameEvent_AttackType_LEFT_HOOK = 3,
  GameEvent_AttackType_RIGHT_HOOK = 4,
  GameEvent_AttackType_LEFT_UPPERCUT = 5,
  GameEvent_AttackType_RIGHT_UPPERCUT = 6,
  GameEvent_AttackType_LEFT_CHOP = 7,
  GameEvent_AttackType_RIGHT_CHOP = 8,
  GameEvent_AttackType_HADOUKEN = 9,
  GameEvent_AttackType_SONIC_BOOM = 10,
  GameEvent_AttackType_LEFT_SHORYUKEN_ATTACK = 11,
  GameEvent_AttackType_RIGHT_SHORYUKEN_ATTACK = 12,
  GameEvent_AttackType_DOUBLE_LARIAT_ATTACK = 13,
  GameEvent_AttackType_QUADRUPLE_LARIAT_ATTACK = 14,
  GameEvent_AttackType_SUMO_HEADBUTT_ATTACK = 15,
  GameEvent_AttackType_LEFT_ONE_HUNDRED_HAND_SLAP_ATTACK = 16,
  GameEvent_AttackType_RIGHT_ONE_HUNDRED_HAND_SLAP_ATTACK = 17,
  GameEvent_AttackType_TWO_HANDED_ONE_HUNDRED_HAND_SLAP_ATTACK = 18,
  GameEvent_AttackType_PSYCHO_CRUSHER_ATTACK = 19,
  GameEvent_AttackType_YMCA_ATTACK = 20,
  GameEvent_AttackType_NYAN_CAT_ATTACK = 21,
  GameEvent_AttackType_DISCO_STU_ATTACK = 22,
  GameEvent_AttackType_ARM_WINDMILL_ATTACK = 23,
  GameEvent_AttackType_SUCK_IT_ATTACK = 24,
  GameEvent_AttackType_LEFT_VAFANAPOLI_ATTACK = 25,
  GameEvent_AttackType_RIGHT_VAFANAPOLI_ATTACK = 26
};
bool GameEvent_AttackType_IsValid(int value);
const GameEvent_AttackType GameEvent_AttackType_AttackType_MIN = GameEvent_AttackType_CUSTOM_UNDEFINED;
const GameEvent_AttackType GameEvent_AttackType_AttackType_MAX = GameEvent_AttackType_RIGHT_VAFANAPOLI_ATTACK;
const int GameEvent_AttackType_AttackType_ARRAYSIZE = GameEvent_AttackType_AttackType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameEvent_AttackType_descriptor();
inline const ::std::string& GameEvent_AttackType_Name(GameEvent_AttackType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameEvent_AttackType_descriptor(), value);
}
inline bool GameEvent_AttackType_Parse(
    const ::std::string& name, GameEvent_AttackType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameEvent_AttackType>(
    GameEvent_AttackType_descriptor(), name, value);
}
enum GameEvent_RingmasterActionType {
  GameEvent_RingmasterActionType_LEFT_HALF_RING_ACTION = 0,
  GameEvent_RingmasterActionType_RIGHT_HALF_RING_ACTION = 1,
  GameEvent_RingmasterActionType_LEFT_JAB_ACTION = 2,
  GameEvent_RingmasterActionType_RIGHT_JAB_ACTION = 3,
  GameEvent_RingmasterActionType_ERUPTION_ACTION = 4,
  GameEvent_RingmasterActionType_LEFT_CIRCLE_ACTION = 5,
  GameEvent_RingmasterActionType_RIGHT_CIRCLE_ACTION = 6,
  GameEvent_RingmasterActionType_HADOUKEN_ACTION = 7,
  GameEvent_RingmasterActionType_DRUM_ACTION = 8
};
bool GameEvent_RingmasterActionType_IsValid(int value);
const GameEvent_RingmasterActionType GameEvent_RingmasterActionType_RingmasterActionType_MIN = GameEvent_RingmasterActionType_LEFT_HALF_RING_ACTION;
const GameEvent_RingmasterActionType GameEvent_RingmasterActionType_RingmasterActionType_MAX = GameEvent_RingmasterActionType_DRUM_ACTION;
const int GameEvent_RingmasterActionType_RingmasterActionType_ARRAYSIZE = GameEvent_RingmasterActionType_RingmasterActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameEvent_RingmasterActionType_descriptor();
inline const ::std::string& GameEvent_RingmasterActionType_Name(GameEvent_RingmasterActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameEvent_RingmasterActionType_descriptor(), value);
}
inline bool GameEvent_RingmasterActionType_Parse(
    const ::std::string& name, GameEvent_RingmasterActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameEvent_RingmasterActionType>(
    GameEvent_RingmasterActionType_descriptor(), name, value);
}
enum GameEvent_RoundBeginCountdownTime {
  GameEvent_RoundBeginCountdownTime_THREE = 0,
  GameEvent_RoundBeginCountdownTime_TWO = 1,
  GameEvent_RoundBeginCountdownTime_ONE = 2,
  GameEvent_RoundBeginCountdownTime_FIGHT = 3
};
bool GameEvent_RoundBeginCountdownTime_IsValid(int value);
const GameEvent_RoundBeginCountdownTime GameEvent_RoundBeginCountdownTime_RoundBeginCountdownTime_MIN = GameEvent_RoundBeginCountdownTime_THREE;
const GameEvent_RoundBeginCountdownTime GameEvent_RoundBeginCountdownTime_RoundBeginCountdownTime_MAX = GameEvent_RoundBeginCountdownTime_FIGHT;
const int GameEvent_RoundBeginCountdownTime_RoundBeginCountdownTime_ARRAYSIZE = GameEvent_RoundBeginCountdownTime_RoundBeginCountdownTime_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameEvent_RoundBeginCountdownTime_descriptor();
inline const ::std::string& GameEvent_RoundBeginCountdownTime_Name(GameEvent_RoundBeginCountdownTime value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameEvent_RoundBeginCountdownTime_descriptor(), value);
}
inline bool GameEvent_RoundBeginCountdownTime_Parse(
    const ::std::string& name, GameEvent_RoundBeginCountdownTime* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameEvent_RoundBeginCountdownTime>(
    GameEvent_RoundBeginCountdownTime_descriptor(), name, value);
}
// ===================================================================

class GameEvent_FireEmitter : public ::google::protobuf::Message {
 public:
  GameEvent_FireEmitter();
  virtual ~GameEvent_FireEmitter();
  
  GameEvent_FireEmitter(const GameEvent_FireEmitter& from);
  
  inline GameEvent_FireEmitter& operator=(const GameEvent_FireEmitter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameEvent_FireEmitter& default_instance();
  
  void Swap(GameEvent_FireEmitter* other);
  
  // implements Message ----------------------------------------------
  
  GameEvent_FireEmitter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameEvent_FireEmitter& from);
  void MergeFrom(const GameEvent_FireEmitter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 emitterIndex = 1;
  inline bool has_emitterindex() const;
  inline void clear_emitterindex();
  static const int kEmitterIndexFieldNumber = 1;
  inline ::google::protobuf::int32 emitterindex() const;
  inline void set_emitterindex(::google::protobuf::int32 value);
  
  // required .guiprotocol.GameEvent.FireEmitterType emitterType = 2;
  inline bool has_emittertype() const;
  inline void clear_emittertype();
  static const int kEmitterTypeFieldNumber = 2;
  inline ::guiprotocol::GameEvent_FireEmitterType emittertype() const;
  inline void set_emittertype(::guiprotocol::GameEvent_FireEmitterType value);
  
  // required float intensityRingmaster = 3;
  inline bool has_intensityringmaster() const;
  inline void clear_intensityringmaster();
  static const int kIntensityRingmasterFieldNumber = 3;
  inline float intensityringmaster() const;
  inline void set_intensityringmaster(float value);
  
  // required float intensityPlayer1 = 4;
  inline bool has_intensityplayer1() const;
  inline void clear_intensityplayer1();
  static const int kIntensityPlayer1FieldNumber = 4;
  inline float intensityplayer1() const;
  inline void set_intensityplayer1(float value);
  
  // required float intensityPlayer2 = 5;
  inline bool has_intensityplayer2() const;
  inline void clear_intensityplayer2();
  static const int kIntensityPlayer2FieldNumber = 5;
  inline float intensityplayer2() const;
  inline void set_intensityplayer2(float value);
  
  // @@protoc_insertion_point(class_scope:guiprotocol.GameEvent.FireEmitter)
 private:
  inline void set_has_emitterindex();
  inline void clear_has_emitterindex();
  inline void set_has_emittertype();
  inline void clear_has_emittertype();
  inline void set_has_intensityringmaster();
  inline void clear_has_intensityringmaster();
  inline void set_has_intensityplayer1();
  inline void clear_has_intensityplayer1();
  inline void set_has_intensityplayer2();
  inline void clear_has_intensityplayer2();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 emitterindex_;
  int emittertype_;
  float intensityringmaster_;
  float intensityplayer1_;
  float intensityplayer2_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();
  
  void InitAsDefaultInstance();
  static GameEvent_FireEmitter* default_instance_;
};
// -------------------------------------------------------------------

class GameEvent : public ::google::protobuf::Message {
 public:
  GameEvent();
  virtual ~GameEvent();
  
  GameEvent(const GameEvent& from);
  
  inline GameEvent& operator=(const GameEvent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameEvent& default_instance();
  
  void Swap(GameEvent* other);
  
  // implements Message ----------------------------------------------
  
  GameEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameEvent& from);
  void MergeFrom(const GameEvent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef GameEvent_FireEmitter FireEmitter;
  
  typedef GameEvent_EventType EventType;
  static const EventType GAME_INFO_REFRESH = GameEvent_EventType_GAME_INFO_REFRESH;
  static const EventType FIRE_EMITTER_CHANGED = GameEvent_EventType_FIRE_EMITTER_CHANGED;
  static const EventType GAME_STATE_CHANGED = GameEvent_EventType_GAME_STATE_CHANGED;
  static const EventType PLAYER_HEALTH_CHANGED = GameEvent_EventType_PLAYER_HEALTH_CHANGED;
  static const EventType ROUND_PLAY_TIMER_CHANGED = GameEvent_EventType_ROUND_PLAY_TIMER_CHANGED;
  static const EventType ROUND_BEGIN_TIMER_CHANGED = GameEvent_EventType_ROUND_BEGIN_TIMER_CHANGED;
  static const EventType ROUND_ENDED = GameEvent_EventType_ROUND_ENDED;
  static const EventType MATCH_ENDED = GameEvent_EventType_MATCH_ENDED;
  static const EventType PLAYER_ATTACK_ACTION = GameEvent_EventType_PLAYER_ATTACK_ACTION;
  static const EventType PLAYER_BLOCK_ACTION = GameEvent_EventType_PLAYER_BLOCK_ACTION;
  static const EventType RINGMASTER_ACTION = GameEvent_EventType_RINGMASTER_ACTION;
  static const EventType SYSTEM_INFO_REFRESH = GameEvent_EventType_SYSTEM_INFO_REFRESH;
  static const EventType UNRECOGNIZED_GESTURE = GameEvent_EventType_UNRECOGNIZED_GESTURE;
  static inline bool EventType_IsValid(int value) {
    return GameEvent_EventType_IsValid(value);
  }
  static const EventType EventType_MIN =
    GameEvent_EventType_EventType_MIN;
  static const EventType EventType_MAX =
    GameEvent_EventType_EventType_MAX;
  static const int EventType_ARRAYSIZE =
    GameEvent_EventType_EventType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EventType_descriptor() {
    return GameEvent_EventType_descriptor();
  }
  static inline const ::std::string& EventType_Name(EventType value) {
    return GameEvent_EventType_Name(value);
  }
  static inline bool EventType_Parse(const ::std::string& name,
      EventType* value) {
    return GameEvent_EventType_Parse(name, value);
  }
  
  typedef GameEvent_RoundResult RoundResult;
  static const RoundResult ROUND_TIE = GameEvent_RoundResult_ROUND_TIE;
  static const RoundResult PLAYER_1_ROUND_WIN = GameEvent_RoundResult_PLAYER_1_ROUND_WIN;
  static const RoundResult PLAYER_2_ROUND_WIN = GameEvent_RoundResult_PLAYER_2_ROUND_WIN;
  static inline bool RoundResult_IsValid(int value) {
    return GameEvent_RoundResult_IsValid(value);
  }
  static const RoundResult RoundResult_MIN =
    GameEvent_RoundResult_RoundResult_MIN;
  static const RoundResult RoundResult_MAX =
    GameEvent_RoundResult_RoundResult_MAX;
  static const int RoundResult_ARRAYSIZE =
    GameEvent_RoundResult_RoundResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoundResult_descriptor() {
    return GameEvent_RoundResult_descriptor();
  }
  static inline const ::std::string& RoundResult_Name(RoundResult value) {
    return GameEvent_RoundResult_Name(value);
  }
  static inline bool RoundResult_Parse(const ::std::string& name,
      RoundResult* value) {
    return GameEvent_RoundResult_Parse(name, value);
  }
  
  typedef GameEvent_MatchResult MatchResult;
  static const MatchResult PLAYER_1_MATCH_WIN = GameEvent_MatchResult_PLAYER_1_MATCH_WIN;
  static const MatchResult PLAYER_2_MATCH_WIN = GameEvent_MatchResult_PLAYER_2_MATCH_WIN;
  static inline bool MatchResult_IsValid(int value) {
    return GameEvent_MatchResult_IsValid(value);
  }
  static const MatchResult MatchResult_MIN =
    GameEvent_MatchResult_MatchResult_MIN;
  static const MatchResult MatchResult_MAX =
    GameEvent_MatchResult_MatchResult_MAX;
  static const int MatchResult_ARRAYSIZE =
    GameEvent_MatchResult_MatchResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MatchResult_descriptor() {
    return GameEvent_MatchResult_descriptor();
  }
  static inline const ::std::string& MatchResult_Name(MatchResult value) {
    return GameEvent_MatchResult_Name(value);
  }
  static inline bool MatchResult_Parse(const ::std::string& name,
      MatchResult* value) {
    return GameEvent_MatchResult_Parse(name, value);
  }
  
  typedef GameEvent_FireEmitterType FireEmitterType;
  static const FireEmitterType LEFT_RAIL = GameEvent_FireEmitterType_LEFT_RAIL;
  static const FireEmitterType RIGHT_RAIL = GameEvent_FireEmitterType_RIGHT_RAIL;
  static const FireEmitterType OUTER_RING = GameEvent_FireEmitterType_OUTER_RING;
  static inline bool FireEmitterType_IsValid(int value) {
    return GameEvent_FireEmitterType_IsValid(value);
  }
  static const FireEmitterType FireEmitterType_MIN =
    GameEvent_FireEmitterType_FireEmitterType_MIN;
  static const FireEmitterType FireEmitterType_MAX =
    GameEvent_FireEmitterType_FireEmitterType_MAX;
  static const int FireEmitterType_ARRAYSIZE =
    GameEvent_FireEmitterType_FireEmitterType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FireEmitterType_descriptor() {
    return GameEvent_FireEmitterType_descriptor();
  }
  static inline const ::std::string& FireEmitterType_Name(FireEmitterType value) {
    return GameEvent_FireEmitterType_Name(value);
  }
  static inline bool FireEmitterType_Parse(const ::std::string& name,
      FireEmitterType* value) {
    return GameEvent_FireEmitterType_Parse(name, value);
  }
  
  typedef GameEvent_FlameEmitterType FlameEmitterType;
  static const FlameEmitterType ATTACK_FLAME = GameEvent_FlameEmitterType_ATTACK_FLAME;
  static const FlameEmitterType BLOCK_FLAME = GameEvent_FlameEmitterType_BLOCK_FLAME;
  static const FlameEmitterType NON_GAME_FLAME = GameEvent_FlameEmitterType_NON_GAME_FLAME;
  static inline bool FlameEmitterType_IsValid(int value) {
    return GameEvent_FlameEmitterType_IsValid(value);
  }
  static const FlameEmitterType FlameEmitterType_MIN =
    GameEvent_FlameEmitterType_FlameEmitterType_MIN;
  static const FlameEmitterType FlameEmitterType_MAX =
    GameEvent_FlameEmitterType_FlameEmitterType_MAX;
  static const int FlameEmitterType_ARRAYSIZE =
    GameEvent_FlameEmitterType_FlameEmitterType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FlameEmitterType_descriptor() {
    return GameEvent_FlameEmitterType_descriptor();
  }
  static inline const ::std::string& FlameEmitterType_Name(FlameEmitterType value) {
    return GameEvent_FlameEmitterType_Name(value);
  }
  static inline bool FlameEmitterType_Parse(const ::std::string& name,
      FlameEmitterType* value) {
    return GameEvent_FlameEmitterType_Parse(name, value);
  }
  
  typedef GameEvent_AttackType AttackType;
  static const AttackType CUSTOM_UNDEFINED = GameEvent_AttackType_CUSTOM_UNDEFINED;
  static const AttackType LEFT_JAB = GameEvent_AttackType_LEFT_JAB;
  static const AttackType RIGHT_JAB = GameEvent_AttackType_RIGHT_JAB;
  static const AttackType LEFT_HOOK = GameEvent_AttackType_LEFT_HOOK;
  static const AttackType RIGHT_HOOK = GameEvent_AttackType_RIGHT_HOOK;
  static const AttackType LEFT_UPPERCUT = GameEvent_AttackType_LEFT_UPPERCUT;
  static const AttackType RIGHT_UPPERCUT = GameEvent_AttackType_RIGHT_UPPERCUT;
  static const AttackType LEFT_CHOP = GameEvent_AttackType_LEFT_CHOP;
  static const AttackType RIGHT_CHOP = GameEvent_AttackType_RIGHT_CHOP;
  static const AttackType HADOUKEN = GameEvent_AttackType_HADOUKEN;
  static const AttackType SONIC_BOOM = GameEvent_AttackType_SONIC_BOOM;
  static const AttackType LEFT_SHORYUKEN_ATTACK = GameEvent_AttackType_LEFT_SHORYUKEN_ATTACK;
  static const AttackType RIGHT_SHORYUKEN_ATTACK = GameEvent_AttackType_RIGHT_SHORYUKEN_ATTACK;
  static const AttackType DOUBLE_LARIAT_ATTACK = GameEvent_AttackType_DOUBLE_LARIAT_ATTACK;
  static const AttackType QUADRUPLE_LARIAT_ATTACK = GameEvent_AttackType_QUADRUPLE_LARIAT_ATTACK;
  static const AttackType SUMO_HEADBUTT_ATTACK = GameEvent_AttackType_SUMO_HEADBUTT_ATTACK;
  static const AttackType LEFT_ONE_HUNDRED_HAND_SLAP_ATTACK = GameEvent_AttackType_LEFT_ONE_HUNDRED_HAND_SLAP_ATTACK;
  static const AttackType RIGHT_ONE_HUNDRED_HAND_SLAP_ATTACK = GameEvent_AttackType_RIGHT_ONE_HUNDRED_HAND_SLAP_ATTACK;
  static const AttackType TWO_HANDED_ONE_HUNDRED_HAND_SLAP_ATTACK = GameEvent_AttackType_TWO_HANDED_ONE_HUNDRED_HAND_SLAP_ATTACK;
  static const AttackType PSYCHO_CRUSHER_ATTACK = GameEvent_AttackType_PSYCHO_CRUSHER_ATTACK;
  static const AttackType YMCA_ATTACK = GameEvent_AttackType_YMCA_ATTACK;
  static const AttackType NYAN_CAT_ATTACK = GameEvent_AttackType_NYAN_CAT_ATTACK;
  static const AttackType DISCO_STU_ATTACK = GameEvent_AttackType_DISCO_STU_ATTACK;
  static const AttackType ARM_WINDMILL_ATTACK = GameEvent_AttackType_ARM_WINDMILL_ATTACK;
  static const AttackType SUCK_IT_ATTACK = GameEvent_AttackType_SUCK_IT_ATTACK;
  static const AttackType LEFT_VAFANAPOLI_ATTACK = GameEvent_AttackType_LEFT_VAFANAPOLI_ATTACK;
  static const AttackType RIGHT_VAFANAPOLI_ATTACK = GameEvent_AttackType_RIGHT_VAFANAPOLI_ATTACK;
  static inline bool AttackType_IsValid(int value) {
    return GameEvent_AttackType_IsValid(value);
  }
  static const AttackType AttackType_MIN =
    GameEvent_AttackType_AttackType_MIN;
  static const AttackType AttackType_MAX =
    GameEvent_AttackType_AttackType_MAX;
  static const int AttackType_ARRAYSIZE =
    GameEvent_AttackType_AttackType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AttackType_descriptor() {
    return GameEvent_AttackType_descriptor();
  }
  static inline const ::std::string& AttackType_Name(AttackType value) {
    return GameEvent_AttackType_Name(value);
  }
  static inline bool AttackType_Parse(const ::std::string& name,
      AttackType* value) {
    return GameEvent_AttackType_Parse(name, value);
  }
  
  typedef GameEvent_RingmasterActionType RingmasterActionType;
  static const RingmasterActionType LEFT_HALF_RING_ACTION = GameEvent_RingmasterActionType_LEFT_HALF_RING_ACTION;
  static const RingmasterActionType RIGHT_HALF_RING_ACTION = GameEvent_RingmasterActionType_RIGHT_HALF_RING_ACTION;
  static const RingmasterActionType LEFT_JAB_ACTION = GameEvent_RingmasterActionType_LEFT_JAB_ACTION;
  static const RingmasterActionType RIGHT_JAB_ACTION = GameEvent_RingmasterActionType_RIGHT_JAB_ACTION;
  static const RingmasterActionType ERUPTION_ACTION = GameEvent_RingmasterActionType_ERUPTION_ACTION;
  static const RingmasterActionType LEFT_CIRCLE_ACTION = GameEvent_RingmasterActionType_LEFT_CIRCLE_ACTION;
  static const RingmasterActionType RIGHT_CIRCLE_ACTION = GameEvent_RingmasterActionType_RIGHT_CIRCLE_ACTION;
  static const RingmasterActionType HADOUKEN_ACTION = GameEvent_RingmasterActionType_HADOUKEN_ACTION;
  static const RingmasterActionType DRUM_ACTION = GameEvent_RingmasterActionType_DRUM_ACTION;
  static inline bool RingmasterActionType_IsValid(int value) {
    return GameEvent_RingmasterActionType_IsValid(value);
  }
  static const RingmasterActionType RingmasterActionType_MIN =
    GameEvent_RingmasterActionType_RingmasterActionType_MIN;
  static const RingmasterActionType RingmasterActionType_MAX =
    GameEvent_RingmasterActionType_RingmasterActionType_MAX;
  static const int RingmasterActionType_ARRAYSIZE =
    GameEvent_RingmasterActionType_RingmasterActionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RingmasterActionType_descriptor() {
    return GameEvent_RingmasterActionType_descriptor();
  }
  static inline const ::std::string& RingmasterActionType_Name(RingmasterActionType value) {
    return GameEvent_RingmasterActionType_Name(value);
  }
  static inline bool RingmasterActionType_Parse(const ::std::string& name,
      RingmasterActionType* value) {
    return GameEvent_RingmasterActionType_Parse(name, value);
  }
  
  typedef GameEvent_RoundBeginCountdownTime RoundBeginCountdownTime;
  static const RoundBeginCountdownTime THREE = GameEvent_RoundBeginCountdownTime_THREE;
  static const RoundBeginCountdownTime TWO = GameEvent_RoundBeginCountdownTime_TWO;
  static const RoundBeginCountdownTime ONE = GameEvent_RoundBeginCountdownTime_ONE;
  static const RoundBeginCountdownTime FIGHT = GameEvent_RoundBeginCountdownTime_FIGHT;
  static inline bool RoundBeginCountdownTime_IsValid(int value) {
    return GameEvent_RoundBeginCountdownTime_IsValid(value);
  }
  static const RoundBeginCountdownTime RoundBeginCountdownTime_MIN =
    GameEvent_RoundBeginCountdownTime_RoundBeginCountdownTime_MIN;
  static const RoundBeginCountdownTime RoundBeginCountdownTime_MAX =
    GameEvent_RoundBeginCountdownTime_RoundBeginCountdownTime_MAX;
  static const int RoundBeginCountdownTime_ARRAYSIZE =
    GameEvent_RoundBeginCountdownTime_RoundBeginCountdownTime_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoundBeginCountdownTime_descriptor() {
    return GameEvent_RoundBeginCountdownTime_descriptor();
  }
  static inline const ::std::string& RoundBeginCountdownTime_Name(RoundBeginCountdownTime value) {
    return GameEvent_RoundBeginCountdownTime_Name(value);
  }
  static inline bool RoundBeginCountdownTime_Parse(const ::std::string& name,
      RoundBeginCountdownTime* value) {
    return GameEvent_RoundBeginCountdownTime_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .guiprotocol.GameEvent.EventType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::guiprotocol::GameEvent_EventType type() const;
  inline void set_type(::guiprotocol::GameEvent_EventType value);
  
  // optional .guiprotocol.GameEvent.FireEmitter emitter = 2;
  inline bool has_emitter() const;
  inline void clear_emitter();
  static const int kEmitterFieldNumber = 2;
  inline const ::guiprotocol::GameEvent_FireEmitter& emitter() const;
  inline ::guiprotocol::GameEvent_FireEmitter* mutable_emitter();
  inline ::guiprotocol::GameEvent_FireEmitter* release_emitter();
  
  // optional .guiprotocol.GameState oldGameState = 3;
  inline bool has_oldgamestate() const;
  inline void clear_oldgamestate();
  static const int kOldGameStateFieldNumber = 3;
  inline guiprotocol::GameState oldgamestate() const;
  inline void set_oldgamestate(guiprotocol::GameState value);
  
  // optional .guiprotocol.GameState newGameState = 4;
  inline bool has_newgamestate() const;
  inline void clear_newgamestate();
  static const int kNewGameStateFieldNumber = 4;
  inline guiprotocol::GameState newgamestate() const;
  inline void set_newgamestate(guiprotocol::GameState value);
  
  // optional .guiprotocol.GameEvent.MatchResult matchResult = 5;
  inline bool has_matchresult() const;
  inline void clear_matchresult();
  static const int kMatchResultFieldNumber = 5;
  inline ::guiprotocol::GameEvent_MatchResult matchresult() const;
  inline void set_matchresult(::guiprotocol::GameEvent_MatchResult value);
  
  // optional .guiprotocol.Player player = 6;
  inline bool has_player() const;
  inline void clear_player();
  static const int kPlayerFieldNumber = 6;
  inline guiprotocol::Player player() const;
  inline void set_player(guiprotocol::Player value);
  
  // optional .guiprotocol.GameEvent.AttackType attackType = 7;
  inline bool has_attacktype() const;
  inline void clear_attacktype();
  static const int kAttackTypeFieldNumber = 7;
  inline ::guiprotocol::GameEvent_AttackType attacktype() const;
  inline void set_attacktype(::guiprotocol::GameEvent_AttackType value);
  
  // optional float oldHealth = 9;
  inline bool has_oldhealth() const;
  inline void clear_oldhealth();
  static const int kOldHealthFieldNumber = 9;
  inline float oldhealth() const;
  inline void set_oldhealth(float value);
  
  // optional float newHealth = 10;
  inline bool has_newhealth() const;
  inline void clear_newhealth();
  static const int kNewHealthFieldNumber = 10;
  inline float newhealth() const;
  inline void set_newhealth(float value);
  
  // optional int32 roundNumber = 11;
  inline bool has_roundnumber() const;
  inline void clear_roundnumber();
  static const int kRoundNumberFieldNumber = 11;
  inline ::google::protobuf::int32 roundnumber() const;
  inline void set_roundnumber(::google::protobuf::int32 value);
  
  // optional .guiprotocol.GameEvent.RoundBeginCountdownTime roundBeginTimer = 12;
  inline bool has_roundbegintimer() const;
  inline void clear_roundbegintimer();
  static const int kRoundBeginTimerFieldNumber = 12;
  inline ::guiprotocol::GameEvent_RoundBeginCountdownTime roundbegintimer() const;
  inline void set_roundbegintimer(::guiprotocol::GameEvent_RoundBeginCountdownTime value);
  
  // optional .guiprotocol.GameEvent.RoundResult roundResult = 13;
  inline bool has_roundresult() const;
  inline void clear_roundresult();
  static const int kRoundResultFieldNumber = 13;
  inline ::guiprotocol::GameEvent_RoundResult roundresult() const;
  inline void set_roundresult(::guiprotocol::GameEvent_RoundResult value);
  
  // optional bool timedOut = 14;
  inline bool has_timedout() const;
  inline void clear_timedout();
  static const int kTimedOutFieldNumber = 14;
  inline bool timedout() const;
  inline void set_timedout(bool value);
  
  // optional int32 timeInSecs = 15;
  inline bool has_timeinsecs() const;
  inline void clear_timeinsecs();
  static const int kTimeInSecsFieldNumber = 15;
  inline ::google::protobuf::int32 timeinsecs() const;
  inline void set_timeinsecs(::google::protobuf::int32 value);
  
  // optional .guiprotocol.GameState gameState = 16;
  inline bool has_gamestate() const;
  inline void clear_gamestate();
  static const int kGameStateFieldNumber = 16;
  inline guiprotocol::GameState gamestate() const;
  inline void set_gamestate(guiprotocol::GameState value);
  
  // repeated .guiprotocol.GameEvent.RoundResult roundResults = 17;
  inline int roundresults_size() const;
  inline void clear_roundresults();
  static const int kRoundResultsFieldNumber = 17;
  inline ::guiprotocol::GameEvent_RoundResult roundresults(int index) const;
  inline void set_roundresults(int index, ::guiprotocol::GameEvent_RoundResult value);
  inline void add_roundresults(::guiprotocol::GameEvent_RoundResult value);
  inline const ::google::protobuf::RepeatedField<int>& roundresults() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_roundresults();
  
  // optional float player1Health = 18;
  inline bool has_player1health() const;
  inline void clear_player1health();
  static const int kPlayer1HealthFieldNumber = 18;
  inline float player1health() const;
  inline void set_player1health(float value);
  
  // optional float player2Health = 19;
  inline bool has_player2health() const;
  inline void clear_player2health();
  static const int kPlayer2HealthFieldNumber = 19;
  inline float player2health() const;
  inline void set_player2health(float value);
  
  // optional int32 roundInPlayTimer = 20;
  inline bool has_roundinplaytimer() const;
  inline void clear_roundinplaytimer();
  static const int kRoundInPlayTimerFieldNumber = 20;
  inline ::google::protobuf::int32 roundinplaytimer() const;
  inline void set_roundinplaytimer(::google::protobuf::int32 value);
  
  // optional bool player1UnlimitedMovesOn = 22;
  inline bool has_player1unlimitedmoveson() const;
  inline void clear_player1unlimitedmoveson();
  static const int kPlayer1UnlimitedMovesOnFieldNumber = 22;
  inline bool player1unlimitedmoveson() const;
  inline void set_player1unlimitedmoveson(bool value);
  
  // optional bool player2UnlimitedMovesOn = 23;
  inline bool has_player2unlimitedmoveson() const;
  inline void clear_player2unlimitedmoveson();
  static const int kPlayer2UnlimitedMovesOnFieldNumber = 23;
  inline bool player2unlimitedmoveson() const;
  inline void set_player2unlimitedmoveson(bool value);
  
  // optional .guiprotocol.GameEvent.RingmasterActionType ringmasterActionType = 24;
  inline bool has_ringmasteractiontype() const;
  inline void clear_ringmasteractiontype();
  static const int kRingmasterActionTypeFieldNumber = 24;
  inline ::guiprotocol::GameEvent_RingmasterActionType ringmasteractiontype() const;
  inline void set_ringmasteractiontype(::guiprotocol::GameEvent_RingmasterActionType value);
  
  // @@protoc_insertion_point(class_scope:guiprotocol.GameEvent)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_emitter();
  inline void clear_has_emitter();
  inline void set_has_oldgamestate();
  inline void clear_has_oldgamestate();
  inline void set_has_newgamestate();
  inline void clear_has_newgamestate();
  inline void set_has_matchresult();
  inline void clear_has_matchresult();
  inline void set_has_player();
  inline void clear_has_player();
  inline void set_has_attacktype();
  inline void clear_has_attacktype();
  inline void set_has_oldhealth();
  inline void clear_has_oldhealth();
  inline void set_has_newhealth();
  inline void clear_has_newhealth();
  inline void set_has_roundnumber();
  inline void clear_has_roundnumber();
  inline void set_has_roundbegintimer();
  inline void clear_has_roundbegintimer();
  inline void set_has_roundresult();
  inline void clear_has_roundresult();
  inline void set_has_timedout();
  inline void clear_has_timedout();
  inline void set_has_timeinsecs();
  inline void clear_has_timeinsecs();
  inline void set_has_gamestate();
  inline void clear_has_gamestate();
  inline void set_has_player1health();
  inline void clear_has_player1health();
  inline void set_has_player2health();
  inline void clear_has_player2health();
  inline void set_has_roundinplaytimer();
  inline void clear_has_roundinplaytimer();
  inline void set_has_player1unlimitedmoveson();
  inline void clear_has_player1unlimitedmoveson();
  inline void set_has_player2unlimitedmoveson();
  inline void clear_has_player2unlimitedmoveson();
  inline void set_has_ringmasteractiontype();
  inline void clear_has_ringmasteractiontype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::guiprotocol::GameEvent_FireEmitter* emitter_;
  int type_;
  int oldgamestate_;
  int newgamestate_;
  int matchresult_;
  int player_;
  int attacktype_;
  float oldhealth_;
  float newhealth_;
  ::google::protobuf::int32 roundnumber_;
  int roundbegintimer_;
  int roundresult_;
  ::google::protobuf::int32 timeinsecs_;
  ::google::protobuf::RepeatedField<int> roundresults_;
  int gamestate_;
  float player1health_;
  float player2health_;
  bool timedout_;
  bool player1unlimitedmoveson_;
  bool player2unlimitedmoveson_;
  ::google::protobuf::int32 roundinplaytimer_;
  int ringmasteractiontype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];
  
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();
  
  void InitAsDefaultInstance();
  static GameEvent* default_instance_;
};
// ===================================================================


// ===================================================================

// GameEvent_FireEmitter

// required int32 emitterIndex = 1;
inline bool GameEvent_FireEmitter::has_emitterindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameEvent_FireEmitter::set_has_emitterindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameEvent_FireEmitter::clear_has_emitterindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameEvent_FireEmitter::clear_emitterindex() {
  emitterindex_ = 0;
  clear_has_emitterindex();
}
inline ::google::protobuf::int32 GameEvent_FireEmitter::emitterindex() const {
  return emitterindex_;
}
inline void GameEvent_FireEmitter::set_emitterindex(::google::protobuf::int32 value) {
  set_has_emitterindex();
  emitterindex_ = value;
}

// required .guiprotocol.GameEvent.FireEmitterType emitterType = 2;
inline bool GameEvent_FireEmitter::has_emittertype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameEvent_FireEmitter::set_has_emittertype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameEvent_FireEmitter::clear_has_emittertype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameEvent_FireEmitter::clear_emittertype() {
  emittertype_ = 0;
  clear_has_emittertype();
}
inline ::guiprotocol::GameEvent_FireEmitterType GameEvent_FireEmitter::emittertype() const {
  return static_cast< ::guiprotocol::GameEvent_FireEmitterType >(emittertype_);
}
inline void GameEvent_FireEmitter::set_emittertype(::guiprotocol::GameEvent_FireEmitterType value) {
  GOOGLE_DCHECK(::guiprotocol::GameEvent_FireEmitterType_IsValid(value));
  set_has_emittertype();
  emittertype_ = value;
}

// required float intensityRingmaster = 3;
inline bool GameEvent_FireEmitter::has_intensityringmaster() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameEvent_FireEmitter::set_has_intensityringmaster() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameEvent_FireEmitter::clear_has_intensityringmaster() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameEvent_FireEmitter::clear_intensityringmaster() {
  intensityringmaster_ = 0;
  clear_has_intensityringmaster();
}
inline float GameEvent_FireEmitter::intensityringmaster() const {
  return intensityringmaster_;
}
inline void GameEvent_FireEmitter::set_intensityringmaster(float value) {
  set_has_intensityringmaster();
  intensityringmaster_ = value;
}

// required float intensityPlayer1 = 4;
inline bool GameEvent_FireEmitter::has_intensityplayer1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameEvent_FireEmitter::set_has_intensityplayer1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameEvent_FireEmitter::clear_has_intensityplayer1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameEvent_FireEmitter::clear_intensityplayer1() {
  intensityplayer1_ = 0;
  clear_has_intensityplayer1();
}
inline float GameEvent_FireEmitter::intensityplayer1() const {
  return intensityplayer1_;
}
inline void GameEvent_FireEmitter::set_intensityplayer1(float value) {
  set_has_intensityplayer1();
  intensityplayer1_ = value;
}

// required float intensityPlayer2 = 5;
inline bool GameEvent_FireEmitter::has_intensityplayer2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameEvent_FireEmitter::set_has_intensityplayer2() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameEvent_FireEmitter::clear_has_intensityplayer2() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameEvent_FireEmitter::clear_intensityplayer2() {
  intensityplayer2_ = 0;
  clear_has_intensityplayer2();
}
inline float GameEvent_FireEmitter::intensityplayer2() const {
  return intensityplayer2_;
}
inline void GameEvent_FireEmitter::set_intensityplayer2(float value) {
  set_has_intensityplayer2();
  intensityplayer2_ = value;
}

// -------------------------------------------------------------------

// GameEvent

// required .guiprotocol.GameEvent.EventType type = 1;
inline bool GameEvent::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameEvent::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameEvent::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameEvent::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::guiprotocol::GameEvent_EventType GameEvent::type() const {
  return static_cast< ::guiprotocol::GameEvent_EventType >(type_);
}
inline void GameEvent::set_type(::guiprotocol::GameEvent_EventType value) {
  GOOGLE_DCHECK(::guiprotocol::GameEvent_EventType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .guiprotocol.GameEvent.FireEmitter emitter = 2;
inline bool GameEvent::has_emitter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameEvent::set_has_emitter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameEvent::clear_has_emitter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameEvent::clear_emitter() {
  if (emitter_ != NULL) emitter_->::guiprotocol::GameEvent_FireEmitter::Clear();
  clear_has_emitter();
}
inline const ::guiprotocol::GameEvent_FireEmitter& GameEvent::emitter() const {
  return emitter_ != NULL ? *emitter_ : *default_instance_->emitter_;
}
inline ::guiprotocol::GameEvent_FireEmitter* GameEvent::mutable_emitter() {
  set_has_emitter();
  if (emitter_ == NULL) emitter_ = new ::guiprotocol::GameEvent_FireEmitter;
  return emitter_;
}
inline ::guiprotocol::GameEvent_FireEmitter* GameEvent::release_emitter() {
  clear_has_emitter();
  ::guiprotocol::GameEvent_FireEmitter* temp = emitter_;
  emitter_ = NULL;
  return temp;
}

// optional .guiprotocol.GameState oldGameState = 3;
inline bool GameEvent::has_oldgamestate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameEvent::set_has_oldgamestate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameEvent::clear_has_oldgamestate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameEvent::clear_oldgamestate() {
  oldgamestate_ = 0;
  clear_has_oldgamestate();
}
inline guiprotocol::GameState GameEvent::oldgamestate() const {
  return static_cast< guiprotocol::GameState >(oldgamestate_);
}
inline void GameEvent::set_oldgamestate(guiprotocol::GameState value) {
  GOOGLE_DCHECK(guiprotocol::GameState_IsValid(value));
  set_has_oldgamestate();
  oldgamestate_ = value;
}

// optional .guiprotocol.GameState newGameState = 4;
inline bool GameEvent::has_newgamestate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameEvent::set_has_newgamestate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameEvent::clear_has_newgamestate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameEvent::clear_newgamestate() {
  newgamestate_ = 0;
  clear_has_newgamestate();
}
inline guiprotocol::GameState GameEvent::newgamestate() const {
  return static_cast< guiprotocol::GameState >(newgamestate_);
}
inline void GameEvent::set_newgamestate(guiprotocol::GameState value) {
  GOOGLE_DCHECK(guiprotocol::GameState_IsValid(value));
  set_has_newgamestate();
  newgamestate_ = value;
}

// optional .guiprotocol.GameEvent.MatchResult matchResult = 5;
inline bool GameEvent::has_matchresult() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameEvent::set_has_matchresult() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameEvent::clear_has_matchresult() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameEvent::clear_matchresult() {
  matchresult_ = 0;
  clear_has_matchresult();
}
inline ::guiprotocol::GameEvent_MatchResult GameEvent::matchresult() const {
  return static_cast< ::guiprotocol::GameEvent_MatchResult >(matchresult_);
}
inline void GameEvent::set_matchresult(::guiprotocol::GameEvent_MatchResult value) {
  GOOGLE_DCHECK(::guiprotocol::GameEvent_MatchResult_IsValid(value));
  set_has_matchresult();
  matchresult_ = value;
}

// optional .guiprotocol.Player player = 6;
inline bool GameEvent::has_player() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameEvent::set_has_player() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameEvent::clear_has_player() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameEvent::clear_player() {
  player_ = 0;
  clear_has_player();
}
inline guiprotocol::Player GameEvent::player() const {
  return static_cast< guiprotocol::Player >(player_);
}
inline void GameEvent::set_player(guiprotocol::Player value) {
  GOOGLE_DCHECK(guiprotocol::Player_IsValid(value));
  set_has_player();
  player_ = value;
}

// optional .guiprotocol.GameEvent.AttackType attackType = 7;
inline bool GameEvent::has_attacktype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameEvent::set_has_attacktype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameEvent::clear_has_attacktype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameEvent::clear_attacktype() {
  attacktype_ = 0;
  clear_has_attacktype();
}
inline ::guiprotocol::GameEvent_AttackType GameEvent::attacktype() const {
  return static_cast< ::guiprotocol::GameEvent_AttackType >(attacktype_);
}
inline void GameEvent::set_attacktype(::guiprotocol::GameEvent_AttackType value) {
  GOOGLE_DCHECK(::guiprotocol::GameEvent_AttackType_IsValid(value));
  set_has_attacktype();
  attacktype_ = value;
}

// optional float oldHealth = 9;
inline bool GameEvent::has_oldhealth() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameEvent::set_has_oldhealth() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameEvent::clear_has_oldhealth() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameEvent::clear_oldhealth() {
  oldhealth_ = 0;
  clear_has_oldhealth();
}
inline float GameEvent::oldhealth() const {
  return oldhealth_;
}
inline void GameEvent::set_oldhealth(float value) {
  set_has_oldhealth();
  oldhealth_ = value;
}

// optional float newHealth = 10;
inline bool GameEvent::has_newhealth() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GameEvent::set_has_newhealth() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GameEvent::clear_has_newhealth() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GameEvent::clear_newhealth() {
  newhealth_ = 0;
  clear_has_newhealth();
}
inline float GameEvent::newhealth() const {
  return newhealth_;
}
inline void GameEvent::set_newhealth(float value) {
  set_has_newhealth();
  newhealth_ = value;
}

// optional int32 roundNumber = 11;
inline bool GameEvent::has_roundnumber() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GameEvent::set_has_roundnumber() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GameEvent::clear_has_roundnumber() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GameEvent::clear_roundnumber() {
  roundnumber_ = 0;
  clear_has_roundnumber();
}
inline ::google::protobuf::int32 GameEvent::roundnumber() const {
  return roundnumber_;
}
inline void GameEvent::set_roundnumber(::google::protobuf::int32 value) {
  set_has_roundnumber();
  roundnumber_ = value;
}

// optional .guiprotocol.GameEvent.RoundBeginCountdownTime roundBeginTimer = 12;
inline bool GameEvent::has_roundbegintimer() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GameEvent::set_has_roundbegintimer() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GameEvent::clear_has_roundbegintimer() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GameEvent::clear_roundbegintimer() {
  roundbegintimer_ = 0;
  clear_has_roundbegintimer();
}
inline ::guiprotocol::GameEvent_RoundBeginCountdownTime GameEvent::roundbegintimer() const {
  return static_cast< ::guiprotocol::GameEvent_RoundBeginCountdownTime >(roundbegintimer_);
}
inline void GameEvent::set_roundbegintimer(::guiprotocol::GameEvent_RoundBeginCountdownTime value) {
  GOOGLE_DCHECK(::guiprotocol::GameEvent_RoundBeginCountdownTime_IsValid(value));
  set_has_roundbegintimer();
  roundbegintimer_ = value;
}

// optional .guiprotocol.GameEvent.RoundResult roundResult = 13;
inline bool GameEvent::has_roundresult() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GameEvent::set_has_roundresult() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GameEvent::clear_has_roundresult() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GameEvent::clear_roundresult() {
  roundresult_ = 0;
  clear_has_roundresult();
}
inline ::guiprotocol::GameEvent_RoundResult GameEvent::roundresult() const {
  return static_cast< ::guiprotocol::GameEvent_RoundResult >(roundresult_);
}
inline void GameEvent::set_roundresult(::guiprotocol::GameEvent_RoundResult value) {
  GOOGLE_DCHECK(::guiprotocol::GameEvent_RoundResult_IsValid(value));
  set_has_roundresult();
  roundresult_ = value;
}

// optional bool timedOut = 14;
inline bool GameEvent::has_timedout() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GameEvent::set_has_timedout() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GameEvent::clear_has_timedout() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GameEvent::clear_timedout() {
  timedout_ = false;
  clear_has_timedout();
}
inline bool GameEvent::timedout() const {
  return timedout_;
}
inline void GameEvent::set_timedout(bool value) {
  set_has_timedout();
  timedout_ = value;
}

// optional int32 timeInSecs = 15;
inline bool GameEvent::has_timeinsecs() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GameEvent::set_has_timeinsecs() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GameEvent::clear_has_timeinsecs() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GameEvent::clear_timeinsecs() {
  timeinsecs_ = 0;
  clear_has_timeinsecs();
}
inline ::google::protobuf::int32 GameEvent::timeinsecs() const {
  return timeinsecs_;
}
inline void GameEvent::set_timeinsecs(::google::protobuf::int32 value) {
  set_has_timeinsecs();
  timeinsecs_ = value;
}

// optional .guiprotocol.GameState gameState = 16;
inline bool GameEvent::has_gamestate() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GameEvent::set_has_gamestate() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GameEvent::clear_has_gamestate() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GameEvent::clear_gamestate() {
  gamestate_ = 0;
  clear_has_gamestate();
}
inline guiprotocol::GameState GameEvent::gamestate() const {
  return static_cast< guiprotocol::GameState >(gamestate_);
}
inline void GameEvent::set_gamestate(guiprotocol::GameState value) {
  GOOGLE_DCHECK(guiprotocol::GameState_IsValid(value));
  set_has_gamestate();
  gamestate_ = value;
}

// repeated .guiprotocol.GameEvent.RoundResult roundResults = 17;
inline int GameEvent::roundresults_size() const {
  return roundresults_.size();
}
inline void GameEvent::clear_roundresults() {
  roundresults_.Clear();
}
inline ::guiprotocol::GameEvent_RoundResult GameEvent::roundresults(int index) const {
  return static_cast< ::guiprotocol::GameEvent_RoundResult >(roundresults_.Get(index));
}
inline void GameEvent::set_roundresults(int index, ::guiprotocol::GameEvent_RoundResult value) {
  GOOGLE_DCHECK(::guiprotocol::GameEvent_RoundResult_IsValid(value));
  roundresults_.Set(index, value);
}
inline void GameEvent::add_roundresults(::guiprotocol::GameEvent_RoundResult value) {
  GOOGLE_DCHECK(::guiprotocol::GameEvent_RoundResult_IsValid(value));
  roundresults_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
GameEvent::roundresults() const {
  return roundresults_;
}
inline ::google::protobuf::RepeatedField<int>*
GameEvent::mutable_roundresults() {
  return &roundresults_;
}

// optional float player1Health = 18;
inline bool GameEvent::has_player1health() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GameEvent::set_has_player1health() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GameEvent::clear_has_player1health() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GameEvent::clear_player1health() {
  player1health_ = 0;
  clear_has_player1health();
}
inline float GameEvent::player1health() const {
  return player1health_;
}
inline void GameEvent::set_player1health(float value) {
  set_has_player1health();
  player1health_ = value;
}

// optional float player2Health = 19;
inline bool GameEvent::has_player2health() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GameEvent::set_has_player2health() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GameEvent::clear_has_player2health() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GameEvent::clear_player2health() {
  player2health_ = 0;
  clear_has_player2health();
}
inline float GameEvent::player2health() const {
  return player2health_;
}
inline void GameEvent::set_player2health(float value) {
  set_has_player2health();
  player2health_ = value;
}

// optional int32 roundInPlayTimer = 20;
inline bool GameEvent::has_roundinplaytimer() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GameEvent::set_has_roundinplaytimer() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GameEvent::clear_has_roundinplaytimer() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GameEvent::clear_roundinplaytimer() {
  roundinplaytimer_ = 0;
  clear_has_roundinplaytimer();
}
inline ::google::protobuf::int32 GameEvent::roundinplaytimer() const {
  return roundinplaytimer_;
}
inline void GameEvent::set_roundinplaytimer(::google::protobuf::int32 value) {
  set_has_roundinplaytimer();
  roundinplaytimer_ = value;
}

// optional bool player1UnlimitedMovesOn = 22;
inline bool GameEvent::has_player1unlimitedmoveson() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GameEvent::set_has_player1unlimitedmoveson() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GameEvent::clear_has_player1unlimitedmoveson() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GameEvent::clear_player1unlimitedmoveson() {
  player1unlimitedmoveson_ = false;
  clear_has_player1unlimitedmoveson();
}
inline bool GameEvent::player1unlimitedmoveson() const {
  return player1unlimitedmoveson_;
}
inline void GameEvent::set_player1unlimitedmoveson(bool value) {
  set_has_player1unlimitedmoveson();
  player1unlimitedmoveson_ = value;
}

// optional bool player2UnlimitedMovesOn = 23;
inline bool GameEvent::has_player2unlimitedmoveson() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GameEvent::set_has_player2unlimitedmoveson() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GameEvent::clear_has_player2unlimitedmoveson() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GameEvent::clear_player2unlimitedmoveson() {
  player2unlimitedmoveson_ = false;
  clear_has_player2unlimitedmoveson();
}
inline bool GameEvent::player2unlimitedmoveson() const {
  return player2unlimitedmoveson_;
}
inline void GameEvent::set_player2unlimitedmoveson(bool value) {
  set_has_player2unlimitedmoveson();
  player2unlimitedmoveson_ = value;
}

// optional .guiprotocol.GameEvent.RingmasterActionType ringmasterActionType = 24;
inline bool GameEvent::has_ringmasteractiontype() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void GameEvent::set_has_ringmasteractiontype() {
  _has_bits_[0] |= 0x00200000u;
}
inline void GameEvent::clear_has_ringmasteractiontype() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void GameEvent::clear_ringmasteractiontype() {
  ringmasteractiontype_ = 0;
  clear_has_ringmasteractiontype();
}
inline ::guiprotocol::GameEvent_RingmasterActionType GameEvent::ringmasteractiontype() const {
  return static_cast< ::guiprotocol::GameEvent_RingmasterActionType >(ringmasteractiontype_);
}
inline void GameEvent::set_ringmasteractiontype(::guiprotocol::GameEvent_RingmasterActionType value) {
  GOOGLE_DCHECK(::guiprotocol::GameEvent_RingmasterActionType_IsValid(value));
  set_has_ringmasteractiontype();
  ringmasteractiontype_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace guiprotocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::guiprotocol::GameEvent_EventType>() {
  return ::guiprotocol::GameEvent_EventType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::guiprotocol::GameEvent_RoundResult>() {
  return ::guiprotocol::GameEvent_RoundResult_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::guiprotocol::GameEvent_MatchResult>() {
  return ::guiprotocol::GameEvent_MatchResult_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::guiprotocol::GameEvent_FireEmitterType>() {
  return ::guiprotocol::GameEvent_FireEmitterType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::guiprotocol::GameEvent_FlameEmitterType>() {
  return ::guiprotocol::GameEvent_FlameEmitterType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::guiprotocol::GameEvent_AttackType>() {
  return ::guiprotocol::GameEvent_AttackType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::guiprotocol::GameEvent_RingmasterActionType>() {
  return ::guiprotocol::GameEvent_RingmasterActionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::guiprotocol::GameEvent_RoundBeginCountdownTime>() {
  return ::guiprotocol::GameEvent_RoundBeginCountdownTime_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_event_2eproto__INCLUDED
