// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gui_command.proto

#ifndef PROTOBUF_gui_5fcommand_2eproto__INCLUDED
#define PROTOBUF_gui_5fcommand_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace guiprotocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_gui_5fcommand_2eproto();
void protobuf_AssignDesc_gui_5fcommand_2eproto();
void protobuf_ShutdownFile_gui_5fcommand_2eproto();

class Command;

enum Command_CommandType {
  Command_CommandType_EXECUTE_GENERIC_ACTION = 0,
  Command_CommandType_EXECUTE_PLAYER_ACTION = 1,
  Command_CommandType_TOGGLE_PAUSE = 2,
  Command_CommandType_KILL_GAME = 3,
  Command_CommandType_NEXT_STATE = 4,
  Command_CommandType_TOUCH_EMITTER = 5,
  Command_CommandType_QUERY_GAME_INFO_REFRESH = 6,
  Command_CommandType_EXECUTE_RINGMASTER_ACTION = 7,
  Command_CommandType_QUERY_SYSTEM_INFO = 8,
  Command_CommandType_UPDATE_PLAYER_STATUS = 9
};
bool Command_CommandType_IsValid(int value);
const Command_CommandType Command_CommandType_CommandType_MIN = Command_CommandType_EXECUTE_GENERIC_ACTION;
const Command_CommandType Command_CommandType_CommandType_MAX = Command_CommandType_UPDATE_PLAYER_STATUS;
const int Command_CommandType_CommandType_ARRAYSIZE = Command_CommandType_CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_CommandType_descriptor();
inline const ::std::string& Command_CommandType_Name(Command_CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_CommandType_descriptor(), value);
}
inline bool Command_CommandType_Parse(
    const ::std::string& name, Command_CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_CommandType>(
    Command_CommandType_descriptor(), name, value);
}
enum Command_PlayerAction {
  Command_PlayerAction_BLOCK = 0,
  Command_PlayerAction_JAB_ATTACK = 1,
  Command_PlayerAction_HOOK_ATTACK = 2,
  Command_PlayerAction_UPPERCUT_ATTACK = 3,
  Command_PlayerAction_CHOP_ATTACK = 4,
  Command_PlayerAction_HADOUKEN_ATTACK = 5,
  Command_PlayerAction_SONIC_BOOM_ATTACK = 6,
  Command_PlayerAction_SHORYUKEN_ATTACK = 7,
  Command_PlayerAction_DOUBLE_LARIAT_ATTACK = 8,
  Command_PlayerAction_QUADRUPLE_LARIAT_ATTACK = 9,
  Command_PlayerAction_SUMO_HEADBUTT_ATTACK = 10,
  Command_PlayerAction_ONE_HUNDRED_HAND_SLAP_ATTACK = 11,
  Command_PlayerAction_PSYCHO_CRUSHER_ATTACK = 12,
  Command_PlayerAction_YMCA_ATTACK = 13,
  Command_PlayerAction_NYAN_CAT_ATTACK = 14,
  Command_PlayerAction_DISCO_STU_ATTACK = 15,
  Command_PlayerAction_ARM_WINDMILL_ATTACK = 16,
  Command_PlayerAction_SUCK_IT_ATTACK = 17,
  Command_PlayerAction_VAFANAPOLI_ATTACK = 18
};
bool Command_PlayerAction_IsValid(int value);
const Command_PlayerAction Command_PlayerAction_PlayerAction_MIN = Command_PlayerAction_BLOCK;
const Command_PlayerAction Command_PlayerAction_PlayerAction_MAX = Command_PlayerAction_VAFANAPOLI_ATTACK;
const int Command_PlayerAction_PlayerAction_ARRAYSIZE = Command_PlayerAction_PlayerAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_PlayerAction_descriptor();
inline const ::std::string& Command_PlayerAction_Name(Command_PlayerAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_PlayerAction_descriptor(), value);
}
inline bool Command_PlayerAction_Parse(
    const ::std::string& name, Command_PlayerAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_PlayerAction>(
    Command_PlayerAction_descriptor(), name, value);
}
enum Command_RingmasterAction {
  Command_RingmasterAction_HALF_RING_ACTION = 0,
  Command_RingmasterAction_JAB_ACTION = 1,
  Command_RingmasterAction_ERUPTION_ACTION = 2,
  Command_RingmasterAction_CIRCLE_ACTION = 3,
  Command_RingmasterAction_HADOUKEN_ACTION = 4,
  Command_RingmasterAction_DRUM_ACTION = 5
};
bool Command_RingmasterAction_IsValid(int value);
const Command_RingmasterAction Command_RingmasterAction_RingmasterAction_MIN = Command_RingmasterAction_HALF_RING_ACTION;
const Command_RingmasterAction Command_RingmasterAction_RingmasterAction_MAX = Command_RingmasterAction_DRUM_ACTION;
const int Command_RingmasterAction_RingmasterAction_ARRAYSIZE = Command_RingmasterAction_RingmasterAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_RingmasterAction_descriptor();
inline const ::std::string& Command_RingmasterAction_Name(Command_RingmasterAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_RingmasterAction_descriptor(), value);
}
inline bool Command_RingmasterAction_Parse(
    const ::std::string& name, Command_RingmasterAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_RingmasterAction>(
    Command_RingmasterAction_descriptor(), name, value);
}
enum Command_FireEmitterType {
  Command_FireEmitterType_LEFT_RAIL = 0,
  Command_FireEmitterType_RIGHT_RAIL = 1,
  Command_FireEmitterType_OUTER_RING = 2
};
bool Command_FireEmitterType_IsValid(int value);
const Command_FireEmitterType Command_FireEmitterType_FireEmitterType_MIN = Command_FireEmitterType_LEFT_RAIL;
const Command_FireEmitterType Command_FireEmitterType_FireEmitterType_MAX = Command_FireEmitterType_OUTER_RING;
const int Command_FireEmitterType_FireEmitterType_ARRAYSIZE = Command_FireEmitterType_FireEmitterType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_FireEmitterType_descriptor();
inline const ::std::string& Command_FireEmitterType_Name(Command_FireEmitterType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_FireEmitterType_descriptor(), value);
}
inline bool Command_FireEmitterType_Parse(
    const ::std::string& name, Command_FireEmitterType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_FireEmitterType>(
    Command_FireEmitterType_descriptor(), name, value);
}
// ===================================================================

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();
  
  Command(const Command& from);
  
  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();
  
  void Swap(Command* other);
  
  // implements Message ----------------------------------------------
  
  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Command_CommandType CommandType;
  static const CommandType EXECUTE_GENERIC_ACTION = Command_CommandType_EXECUTE_GENERIC_ACTION;
  static const CommandType EXECUTE_PLAYER_ACTION = Command_CommandType_EXECUTE_PLAYER_ACTION;
  static const CommandType TOGGLE_PAUSE = Command_CommandType_TOGGLE_PAUSE;
  static const CommandType KILL_GAME = Command_CommandType_KILL_GAME;
  static const CommandType NEXT_STATE = Command_CommandType_NEXT_STATE;
  static const CommandType TOUCH_EMITTER = Command_CommandType_TOUCH_EMITTER;
  static const CommandType QUERY_GAME_INFO_REFRESH = Command_CommandType_QUERY_GAME_INFO_REFRESH;
  static const CommandType EXECUTE_RINGMASTER_ACTION = Command_CommandType_EXECUTE_RINGMASTER_ACTION;
  static const CommandType QUERY_SYSTEM_INFO = Command_CommandType_QUERY_SYSTEM_INFO;
  static const CommandType UPDATE_PLAYER_STATUS = Command_CommandType_UPDATE_PLAYER_STATUS;
  static inline bool CommandType_IsValid(int value) {
    return Command_CommandType_IsValid(value);
  }
  static const CommandType CommandType_MIN =
    Command_CommandType_CommandType_MIN;
  static const CommandType CommandType_MAX =
    Command_CommandType_CommandType_MAX;
  static const int CommandType_ARRAYSIZE =
    Command_CommandType_CommandType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommandType_descriptor() {
    return Command_CommandType_descriptor();
  }
  static inline const ::std::string& CommandType_Name(CommandType value) {
    return Command_CommandType_Name(value);
  }
  static inline bool CommandType_Parse(const ::std::string& name,
      CommandType* value) {
    return Command_CommandType_Parse(name, value);
  }
  
  typedef Command_PlayerAction PlayerAction;
  static const PlayerAction BLOCK = Command_PlayerAction_BLOCK;
  static const PlayerAction JAB_ATTACK = Command_PlayerAction_JAB_ATTACK;
  static const PlayerAction HOOK_ATTACK = Command_PlayerAction_HOOK_ATTACK;
  static const PlayerAction UPPERCUT_ATTACK = Command_PlayerAction_UPPERCUT_ATTACK;
  static const PlayerAction CHOP_ATTACK = Command_PlayerAction_CHOP_ATTACK;
  static const PlayerAction HADOUKEN_ATTACK = Command_PlayerAction_HADOUKEN_ATTACK;
  static const PlayerAction SONIC_BOOM_ATTACK = Command_PlayerAction_SONIC_BOOM_ATTACK;
  static const PlayerAction SHORYUKEN_ATTACK = Command_PlayerAction_SHORYUKEN_ATTACK;
  static const PlayerAction DOUBLE_LARIAT_ATTACK = Command_PlayerAction_DOUBLE_LARIAT_ATTACK;
  static const PlayerAction QUADRUPLE_LARIAT_ATTACK = Command_PlayerAction_QUADRUPLE_LARIAT_ATTACK;
  static const PlayerAction SUMO_HEADBUTT_ATTACK = Command_PlayerAction_SUMO_HEADBUTT_ATTACK;
  static const PlayerAction ONE_HUNDRED_HAND_SLAP_ATTACK = Command_PlayerAction_ONE_HUNDRED_HAND_SLAP_ATTACK;
  static const PlayerAction PSYCHO_CRUSHER_ATTACK = Command_PlayerAction_PSYCHO_CRUSHER_ATTACK;
  static const PlayerAction YMCA_ATTACK = Command_PlayerAction_YMCA_ATTACK;
  static const PlayerAction NYAN_CAT_ATTACK = Command_PlayerAction_NYAN_CAT_ATTACK;
  static const PlayerAction DISCO_STU_ATTACK = Command_PlayerAction_DISCO_STU_ATTACK;
  static const PlayerAction ARM_WINDMILL_ATTACK = Command_PlayerAction_ARM_WINDMILL_ATTACK;
  static const PlayerAction SUCK_IT_ATTACK = Command_PlayerAction_SUCK_IT_ATTACK;
  static const PlayerAction VAFANAPOLI_ATTACK = Command_PlayerAction_VAFANAPOLI_ATTACK;
  static inline bool PlayerAction_IsValid(int value) {
    return Command_PlayerAction_IsValid(value);
  }
  static const PlayerAction PlayerAction_MIN =
    Command_PlayerAction_PlayerAction_MIN;
  static const PlayerAction PlayerAction_MAX =
    Command_PlayerAction_PlayerAction_MAX;
  static const int PlayerAction_ARRAYSIZE =
    Command_PlayerAction_PlayerAction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PlayerAction_descriptor() {
    return Command_PlayerAction_descriptor();
  }
  static inline const ::std::string& PlayerAction_Name(PlayerAction value) {
    return Command_PlayerAction_Name(value);
  }
  static inline bool PlayerAction_Parse(const ::std::string& name,
      PlayerAction* value) {
    return Command_PlayerAction_Parse(name, value);
  }
  
  typedef Command_RingmasterAction RingmasterAction;
  static const RingmasterAction HALF_RING_ACTION = Command_RingmasterAction_HALF_RING_ACTION;
  static const RingmasterAction JAB_ACTION = Command_RingmasterAction_JAB_ACTION;
  static const RingmasterAction ERUPTION_ACTION = Command_RingmasterAction_ERUPTION_ACTION;
  static const RingmasterAction CIRCLE_ACTION = Command_RingmasterAction_CIRCLE_ACTION;
  static const RingmasterAction HADOUKEN_ACTION = Command_RingmasterAction_HADOUKEN_ACTION;
  static const RingmasterAction DRUM_ACTION = Command_RingmasterAction_DRUM_ACTION;
  static inline bool RingmasterAction_IsValid(int value) {
    return Command_RingmasterAction_IsValid(value);
  }
  static const RingmasterAction RingmasterAction_MIN =
    Command_RingmasterAction_RingmasterAction_MIN;
  static const RingmasterAction RingmasterAction_MAX =
    Command_RingmasterAction_RingmasterAction_MAX;
  static const int RingmasterAction_ARRAYSIZE =
    Command_RingmasterAction_RingmasterAction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RingmasterAction_descriptor() {
    return Command_RingmasterAction_descriptor();
  }
  static inline const ::std::string& RingmasterAction_Name(RingmasterAction value) {
    return Command_RingmasterAction_Name(value);
  }
  static inline bool RingmasterAction_Parse(const ::std::string& name,
      RingmasterAction* value) {
    return Command_RingmasterAction_Parse(name, value);
  }
  
  typedef Command_FireEmitterType FireEmitterType;
  static const FireEmitterType LEFT_RAIL = Command_FireEmitterType_LEFT_RAIL;
  static const FireEmitterType RIGHT_RAIL = Command_FireEmitterType_RIGHT_RAIL;
  static const FireEmitterType OUTER_RING = Command_FireEmitterType_OUTER_RING;
  static inline bool FireEmitterType_IsValid(int value) {
    return Command_FireEmitterType_IsValid(value);
  }
  static const FireEmitterType FireEmitterType_MIN =
    Command_FireEmitterType_FireEmitterType_MIN;
  static const FireEmitterType FireEmitterType_MAX =
    Command_FireEmitterType_FireEmitterType_MAX;
  static const int FireEmitterType_ARRAYSIZE =
    Command_FireEmitterType_FireEmitterType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FireEmitterType_descriptor() {
    return Command_FireEmitterType_descriptor();
  }
  static inline const ::std::string& FireEmitterType_Name(FireEmitterType value) {
    return Command_FireEmitterType_Name(value);
  }
  static inline bool FireEmitterType_Parse(const ::std::string& name,
      FireEmitterType* value) {
    return Command_FireEmitterType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .guiprotocol.Command.CommandType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::guiprotocol::Command_CommandType type() const;
  inline void set_type(::guiprotocol::Command_CommandType value);
  
  // optional .guiprotocol.Command.PlayerAction playerAction = 2;
  inline bool has_playeraction() const;
  inline void clear_playeraction();
  static const int kPlayerActionFieldNumber = 2;
  inline ::guiprotocol::Command_PlayerAction playeraction() const;
  inline void set_playeraction(::guiprotocol::Command_PlayerAction value);
  
  // optional .guiprotocol.Player player = 3;
  inline bool has_player() const;
  inline void clear_player();
  static const int kPlayerFieldNumber = 3;
  inline guiprotocol::Player player() const;
  inline void set_player(guiprotocol::Player value);
  
  // optional bool leftHand = 4;
  inline bool has_lefthand() const;
  inline void clear_lefthand();
  static const int kLeftHandFieldNumber = 4;
  inline bool lefthand() const;
  inline void set_lefthand(bool value);
  
  // optional bool rightHand = 5;
  inline bool has_righthand() const;
  inline void clear_righthand();
  static const int kRightHandFieldNumber = 5;
  inline bool righthand() const;
  inline void set_righthand(bool value);
  
  // optional .guiprotocol.Command.FireEmitterType emitterType = 6;
  inline bool has_emittertype() const;
  inline void clear_emittertype();
  static const int kEmitterTypeFieldNumber = 6;
  inline ::guiprotocol::Command_FireEmitterType emittertype() const;
  inline void set_emittertype(::guiprotocol::Command_FireEmitterType value);
  
  // optional float intensity = 7;
  inline bool has_intensity() const;
  inline void clear_intensity();
  static const int kIntensityFieldNumber = 7;
  inline float intensity() const;
  inline void set_intensity(float value);
  
  // optional int32 emitterIndex = 8;
  inline bool has_emitterindex() const;
  inline void clear_emitterindex();
  static const int kEmitterIndexFieldNumber = 8;
  inline ::google::protobuf::int32 emitterindex() const;
  inline void set_emitterindex(::google::protobuf::int32 value);
  
  // repeated .guiprotocol.Player emitterEntities = 9;
  inline int emitterentities_size() const;
  inline void clear_emitterentities();
  static const int kEmitterEntitiesFieldNumber = 9;
  inline guiprotocol::Player emitterentities(int index) const;
  inline void set_emitterentities(int index, guiprotocol::Player value);
  inline void add_emitterentities(guiprotocol::Player value);
  inline const ::google::protobuf::RepeatedField<int>& emitterentities() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_emitterentities();
  
  // optional float dmgPerFlame = 10;
  inline bool has_dmgperflame() const;
  inline void clear_dmgperflame();
  static const int kDmgPerFlameFieldNumber = 10;
  inline float dmgperflame() const;
  inline void set_dmgperflame(float value);
  
  // optional int32 flameWidth = 11;
  inline bool has_flamewidth() const;
  inline void clear_flamewidth();
  static const int kFlameWidthFieldNumber = 11;
  inline ::google::protobuf::int32 flamewidth() const;
  inline void set_flamewidth(::google::protobuf::int32 value);
  
  // optional double durationInSeconds = 12;
  inline bool has_durationinseconds() const;
  inline void clear_durationinseconds();
  static const int kDurationInSecondsFieldNumber = 12;
  inline double durationinseconds() const;
  inline void set_durationinseconds(double value);
  
  // optional double acceleration = 13;
  inline bool has_acceleration() const;
  inline void clear_acceleration();
  static const int kAccelerationFieldNumber = 13;
  inline double acceleration() const;
  inline void set_acceleration(double value);
  
  // optional .guiprotocol.GameState nextState = 14;
  inline bool has_nextstate() const;
  inline void clear_nextstate();
  static const int kNextStateFieldNumber = 14;
  inline guiprotocol::GameState nextstate() const;
  inline void set_nextstate(guiprotocol::GameState value);
  
  // optional .guiprotocol.Command.RingmasterAction ringmasterAction = 15;
  inline bool has_ringmasteraction() const;
  inline void clear_ringmasteraction();
  static const int kRingmasterActionFieldNumber = 15;
  inline ::guiprotocol::Command_RingmasterAction ringmasteraction() const;
  inline void set_ringmasteraction(::guiprotocol::Command_RingmasterAction value);
  
  // optional bool unlimitedMovesOn = 16;
  inline bool has_unlimitedmoveson() const;
  inline void clear_unlimitedmoveson();
  static const int kUnlimitedMovesOnFieldNumber = 16;
  inline bool unlimitedmoveson() const;
  inline void set_unlimitedmoveson(bool value);
  
  // @@protoc_insertion_point(class_scope:guiprotocol.Command)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_playeraction();
  inline void clear_has_playeraction();
  inline void set_has_player();
  inline void clear_has_player();
  inline void set_has_lefthand();
  inline void clear_has_lefthand();
  inline void set_has_righthand();
  inline void clear_has_righthand();
  inline void set_has_emittertype();
  inline void clear_has_emittertype();
  inline void set_has_intensity();
  inline void clear_has_intensity();
  inline void set_has_emitterindex();
  inline void clear_has_emitterindex();
  inline void set_has_dmgperflame();
  inline void clear_has_dmgperflame();
  inline void set_has_flamewidth();
  inline void clear_has_flamewidth();
  inline void set_has_durationinseconds();
  inline void clear_has_durationinseconds();
  inline void set_has_acceleration();
  inline void clear_has_acceleration();
  inline void set_has_nextstate();
  inline void clear_has_nextstate();
  inline void set_has_ringmasteraction();
  inline void clear_has_ringmasteraction();
  inline void set_has_unlimitedmoveson();
  inline void clear_has_unlimitedmoveson();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  int playeraction_;
  int player_;
  int emittertype_;
  float intensity_;
  ::google::protobuf::int32 emitterindex_;
  bool lefthand_;
  bool righthand_;
  bool unlimitedmoveson_;
  float dmgperflame_;
  ::google::protobuf::RepeatedField<int> emitterentities_;
  double durationinseconds_;
  ::google::protobuf::int32 flamewidth_;
  int nextstate_;
  double acceleration_;
  int ringmasteraction_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_gui_5fcommand_2eproto();
  friend void protobuf_AssignDesc_gui_5fcommand_2eproto();
  friend void protobuf_ShutdownFile_gui_5fcommand_2eproto();
  
  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// ===================================================================


// ===================================================================

// Command

// required .guiprotocol.Command.CommandType type = 1;
inline bool Command::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::guiprotocol::Command_CommandType Command::type() const {
  return static_cast< ::guiprotocol::Command_CommandType >(type_);
}
inline void Command::set_type(::guiprotocol::Command_CommandType value) {
  GOOGLE_DCHECK(::guiprotocol::Command_CommandType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .guiprotocol.Command.PlayerAction playerAction = 2;
inline bool Command::has_playeraction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_playeraction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_playeraction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_playeraction() {
  playeraction_ = 0;
  clear_has_playeraction();
}
inline ::guiprotocol::Command_PlayerAction Command::playeraction() const {
  return static_cast< ::guiprotocol::Command_PlayerAction >(playeraction_);
}
inline void Command::set_playeraction(::guiprotocol::Command_PlayerAction value) {
  GOOGLE_DCHECK(::guiprotocol::Command_PlayerAction_IsValid(value));
  set_has_playeraction();
  playeraction_ = value;
}

// optional .guiprotocol.Player player = 3;
inline bool Command::has_player() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command::set_has_player() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command::clear_has_player() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command::clear_player() {
  player_ = 0;
  clear_has_player();
}
inline guiprotocol::Player Command::player() const {
  return static_cast< guiprotocol::Player >(player_);
}
inline void Command::set_player(guiprotocol::Player value) {
  GOOGLE_DCHECK(guiprotocol::Player_IsValid(value));
  set_has_player();
  player_ = value;
}

// optional bool leftHand = 4;
inline bool Command::has_lefthand() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command::set_has_lefthand() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command::clear_has_lefthand() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command::clear_lefthand() {
  lefthand_ = false;
  clear_has_lefthand();
}
inline bool Command::lefthand() const {
  return lefthand_;
}
inline void Command::set_lefthand(bool value) {
  set_has_lefthand();
  lefthand_ = value;
}

// optional bool rightHand = 5;
inline bool Command::has_righthand() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command::set_has_righthand() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command::clear_has_righthand() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command::clear_righthand() {
  righthand_ = false;
  clear_has_righthand();
}
inline bool Command::righthand() const {
  return righthand_;
}
inline void Command::set_righthand(bool value) {
  set_has_righthand();
  righthand_ = value;
}

// optional .guiprotocol.Command.FireEmitterType emitterType = 6;
inline bool Command::has_emittertype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Command::set_has_emittertype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Command::clear_has_emittertype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Command::clear_emittertype() {
  emittertype_ = 0;
  clear_has_emittertype();
}
inline ::guiprotocol::Command_FireEmitterType Command::emittertype() const {
  return static_cast< ::guiprotocol::Command_FireEmitterType >(emittertype_);
}
inline void Command::set_emittertype(::guiprotocol::Command_FireEmitterType value) {
  GOOGLE_DCHECK(::guiprotocol::Command_FireEmitterType_IsValid(value));
  set_has_emittertype();
  emittertype_ = value;
}

// optional float intensity = 7;
inline bool Command::has_intensity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Command::set_has_intensity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Command::clear_has_intensity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Command::clear_intensity() {
  intensity_ = 0;
  clear_has_intensity();
}
inline float Command::intensity() const {
  return intensity_;
}
inline void Command::set_intensity(float value) {
  set_has_intensity();
  intensity_ = value;
}

// optional int32 emitterIndex = 8;
inline bool Command::has_emitterindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Command::set_has_emitterindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Command::clear_has_emitterindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Command::clear_emitterindex() {
  emitterindex_ = 0;
  clear_has_emitterindex();
}
inline ::google::protobuf::int32 Command::emitterindex() const {
  return emitterindex_;
}
inline void Command::set_emitterindex(::google::protobuf::int32 value) {
  set_has_emitterindex();
  emitterindex_ = value;
}

// repeated .guiprotocol.Player emitterEntities = 9;
inline int Command::emitterentities_size() const {
  return emitterentities_.size();
}
inline void Command::clear_emitterentities() {
  emitterentities_.Clear();
}
inline guiprotocol::Player Command::emitterentities(int index) const {
  return static_cast< guiprotocol::Player >(emitterentities_.Get(index));
}
inline void Command::set_emitterentities(int index, guiprotocol::Player value) {
  GOOGLE_DCHECK(guiprotocol::Player_IsValid(value));
  emitterentities_.Set(index, value);
}
inline void Command::add_emitterentities(guiprotocol::Player value) {
  GOOGLE_DCHECK(guiprotocol::Player_IsValid(value));
  emitterentities_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
Command::emitterentities() const {
  return emitterentities_;
}
inline ::google::protobuf::RepeatedField<int>*
Command::mutable_emitterentities() {
  return &emitterentities_;
}

// optional float dmgPerFlame = 10;
inline bool Command::has_dmgperflame() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Command::set_has_dmgperflame() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Command::clear_has_dmgperflame() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Command::clear_dmgperflame() {
  dmgperflame_ = 0;
  clear_has_dmgperflame();
}
inline float Command::dmgperflame() const {
  return dmgperflame_;
}
inline void Command::set_dmgperflame(float value) {
  set_has_dmgperflame();
  dmgperflame_ = value;
}

// optional int32 flameWidth = 11;
inline bool Command::has_flamewidth() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Command::set_has_flamewidth() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Command::clear_has_flamewidth() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Command::clear_flamewidth() {
  flamewidth_ = 0;
  clear_has_flamewidth();
}
inline ::google::protobuf::int32 Command::flamewidth() const {
  return flamewidth_;
}
inline void Command::set_flamewidth(::google::protobuf::int32 value) {
  set_has_flamewidth();
  flamewidth_ = value;
}

// optional double durationInSeconds = 12;
inline bool Command::has_durationinseconds() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Command::set_has_durationinseconds() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Command::clear_has_durationinseconds() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Command::clear_durationinseconds() {
  durationinseconds_ = 0;
  clear_has_durationinseconds();
}
inline double Command::durationinseconds() const {
  return durationinseconds_;
}
inline void Command::set_durationinseconds(double value) {
  set_has_durationinseconds();
  durationinseconds_ = value;
}

// optional double acceleration = 13;
inline bool Command::has_acceleration() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Command::set_has_acceleration() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Command::clear_has_acceleration() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Command::clear_acceleration() {
  acceleration_ = 0;
  clear_has_acceleration();
}
inline double Command::acceleration() const {
  return acceleration_;
}
inline void Command::set_acceleration(double value) {
  set_has_acceleration();
  acceleration_ = value;
}

// optional .guiprotocol.GameState nextState = 14;
inline bool Command::has_nextstate() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Command::set_has_nextstate() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Command::clear_has_nextstate() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Command::clear_nextstate() {
  nextstate_ = 0;
  clear_has_nextstate();
}
inline guiprotocol::GameState Command::nextstate() const {
  return static_cast< guiprotocol::GameState >(nextstate_);
}
inline void Command::set_nextstate(guiprotocol::GameState value) {
  GOOGLE_DCHECK(guiprotocol::GameState_IsValid(value));
  set_has_nextstate();
  nextstate_ = value;
}

// optional .guiprotocol.Command.RingmasterAction ringmasterAction = 15;
inline bool Command::has_ringmasteraction() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Command::set_has_ringmasteraction() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Command::clear_has_ringmasteraction() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Command::clear_ringmasteraction() {
  ringmasteraction_ = 0;
  clear_has_ringmasteraction();
}
inline ::guiprotocol::Command_RingmasterAction Command::ringmasteraction() const {
  return static_cast< ::guiprotocol::Command_RingmasterAction >(ringmasteraction_);
}
inline void Command::set_ringmasteraction(::guiprotocol::Command_RingmasterAction value) {
  GOOGLE_DCHECK(::guiprotocol::Command_RingmasterAction_IsValid(value));
  set_has_ringmasteraction();
  ringmasteraction_ = value;
}

// optional bool unlimitedMovesOn = 16;
inline bool Command::has_unlimitedmoveson() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Command::set_has_unlimitedmoveson() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Command::clear_has_unlimitedmoveson() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Command::clear_unlimitedmoveson() {
  unlimitedmoveson_ = false;
  clear_has_unlimitedmoveson();
}
inline bool Command::unlimitedmoveson() const {
  return unlimitedmoveson_;
}
inline void Command::set_unlimitedmoveson(bool value) {
  set_has_unlimitedmoveson();
  unlimitedmoveson_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace guiprotocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::guiprotocol::Command_CommandType>() {
  return ::guiprotocol::Command_CommandType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::guiprotocol::Command_PlayerAction>() {
  return ::guiprotocol::Command_PlayerAction_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::guiprotocol::Command_RingmasterAction>() {
  return ::guiprotocol::Command_RingmasterAction_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::guiprotocol::Command_FireEmitterType>() {
  return ::guiprotocol::Command_FireEmitterType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gui_5fcommand_2eproto__INCLUDED
